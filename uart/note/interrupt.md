# PL011 UART 인터럽트 처리 흐름

## 1. 개요
이 문서는 Raspberry Pi 4의 PL011 UART3를 기반으로 한 인터럽트 처리 과정을 설명한다.  
하드웨어 이벤트가 발생하면 PL011이 인터럽트를 발생시키고, 커널 드라이버의 ISR(Interrupt Service Routine)이 이를 처리하여 사용자 공간 애플리케이션과 데이터를 주고받는다.


## 2. 흐름 요약
1. **하드웨어(PL011)**  
   - 송수신 FIFO 상태 감시  
   - 이벤트 발생 시 IRQ 라인(예: IRQ 50)을 통해 CPU에 인터럽트 요청  
   - 인터럽트 원인:  
     - RX 데이터 도착  
     - RX Timeout 발생  
     - TX FIFO 공간 확보  
     - 프레임, 패리티, 브레이크, 오버런 등 에러 발생  

2. **커널 드라이버 (ISR 처리)**  
   - `UART_MIS` 레지스터 읽어 이벤트 종류 판별  
   - RX 이벤트 → FIFO에서 데이터 읽어 RX 링버퍼에 저장  
   - TX 이벤트 → TX 링버퍼에서 데이터 꺼내 FIFO로 전송  
   - 해당 이벤트 비트 `UART_ICR`에 기록하여 인터럽트 클리어  

3. **사용자 공간 애플리케이션**  
   - `read()` 호출 시 RX 링버퍼에서 데이터 수신  
   - `write()` 호출 시 TX 링버퍼에 데이터 저장  
   - TX 링버퍼에 데이터가 생기면 드라이버가 TX 인터럽트를 활성화하여 송신 처리


## 3. 세부 처리 단계

### 3.1 인터럽트 설정
드라이버 `open()` 시:
- `UART_IMSC` 레지스터에서 RXIM, RTIM 비트 활성화  
  → 데이터 수신과 RX Timeout 이벤트 허용  
- TXIM 비트는 송신할 데이터가 있을 때만 활성화

### 3.2 인터럽트 발생 → ISR 진입
- PL011이 IRQ 발생  
- 커널이 등록된 `my_uart3_isr()` 호출

### 3.3 ISR 내부 동작
#### (1) RX 처리
- `UART_FR` 확인 후 RX FIFO가 비어있지 않으면 `UART_DR`에서 데이터 읽기  
- RX 링버퍼에 저장  
- RXIC, RTIC, FEIC, PEIC, BEIC, OEIC 비트로 인터럽트 및 에러 플래그 클리어

#### (2) TX 처리
- TX 링버퍼에서 대기 중인 데이터 꺼내 FIFO에 채움  
- 송신할 데이터가 없으면 TX 인터럽트 비활성화  
- TXIC 비트로 인터럽트 클리어

### 3.4 사용자 공간과의 연계
- **read()**: RX 링버퍼에서 데이터 복사 후 사용자 버퍼로 전달  
- **write()**: 사용자 데이터 TX 링버퍼에 저장 후 TX 인터럽트 활성화


## 4. PL011 ↔ 커널 ISR ↔ 사용자 공간 관계

```

[PL011 하드웨어]
├── RX FIFO → 데이터 도착/RX Timeout 시 IRQ 발생
├── TX FIFO → 공간 생기면 IRQ 발생
↓
[커널 ISR]
├── RX 이벤트: FIFO → RX 링버퍼
├── TX 이벤트: TX 링버퍼 → FIFO
└── 인터럽트 클리어 (UART\_ICR)
↓
[사용자 공간]
├── read(): RX 링버퍼 → 앱
└── write(): 앱 → TX 링버퍼

```

## 5. 특징
- RX Timeout 사용으로 소량 데이터도 지연 없이 처리 가능
- TX 인터럽트는 필요 시만 활성화하여 불필요한 CPU 부하 방지
- 링버퍼로 인터럽트 처리와 사용자 I/O 속도 차이를 완충

