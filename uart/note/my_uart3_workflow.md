# my_uart3 Work Flow

## 1. 모듈 로드 과정

1. **IRQ 파라미터 확인**

   * 모듈 파라미터 `irq` 값이 설정되지 않았으면 에러 출력 후 로드 실패.
2. **캐릭터 디바이스 등록**

   * `register_chrdev()` 호출. 실패 시 종료.
3. **UART3 레지스터 매핑**

   * `ioremap()`으로 물리 주소를 가상 주소에 매핑. 실패 시 등록 해제 후 종료.
4. **대기큐 초기화**

   * 수신 대기큐(`rx_wq`)와 송신 대기큐(`tx_wq`) 초기화.
5. **인터럽트 핸들러 등록**

   * `request_irq()`로 ISR 등록. 실패 시 자원 해제 후 종료.
6. **로드 완료**

   * 정상 로드되면 로그 출력.


## 2. `open()` 처리

1. **UART 비활성화**

   * CR 레지스터를 0으로 설정.
2. **대기 중 인터럽트 클리어**

   * ICR 레지스터에 0x7FF 기록.
3. **보오레이트 설정**

   * IBRD/FBRD 레지스터 값 설정.
4. **프레임 포맷 설정**

   * LCRH 레지스터로 FIFO 사용, 8N1 모드 설정.
5. **FIFO 트리거 레벨 설정**

   * IFLS 레지스터로 RX/TX 각각 1/2 지점 지정.
6. **수신/타임아웃 인터럽트 마스크 활성화**

   * IMSC에 RXIM, RTIM 설정.
7. **UART 송수신 활성화**

   * CR 레지스터에 RX, TX, UARTEN 비트 설정.
8. **open 완료**.


## 3. `write()` 처리

1. **유저 버퍼에서 1바이트씩 복사**

   * `copy_from_user()` 사용. 실패 시 `-EFAULT` 반환.
2. **송신 링버퍼 잠금**

   * `spin_lock()`으로 보호.
3. **링버퍼 상태 확인**

   * 가득 차면 잠금 해제 후 TX FIFO 여유 확인. 여유 있으면 바로 DR에 기록, 없으면 전송 루프 중단.
4. **빈 공간이 있으면 링버퍼에 적재**.
5. **잠금 해제**.
6. **`uart_tx_kick()` 호출**

   * 송신 동작 트리거.
7. **전송한 바이트 수 반환**.

## 4. `uart_tx_kick()` 처리

1. **송신 링버퍼 잠금**.
2. **전송 가능 여부 확인**

   * 링버퍼 비어있지 않고 FIFO 여유 있으면 전송 반복.
3. **모든 전송 끝나면 TX 인터럽트 상태 확인**

   * 비었으면 TXIM 비활성화 후 송신 대기중인 프로세스 깨움.
   * 남아있으면 TXIM 활성화.
4. **잠금 해제 후 종료**.


## 5. `read()` 처리

1. **읽기 크기 제한**

   * 내부 임시 버퍼 크기(128바이트) 이하로 제한.
2. **수신 링버퍼 잠금**.
3. **데이터 복사**

   * 링버퍼에서 임시 버퍼로 읽음.
4. **잠금 해제**.
5. **데이터 없음 여부 확인**

   * 없으면 `0` 반환.
6. **`copy_to_user()` 호출**

   * 실패 시 `-EFAULT` 반환.
7. **읽은 바이트 수 반환**.


## 6. 인터럽트 서비스 루틴 (ISR)

1. **MIS 레지스터 읽기**

   * 인터럽트 원인 확인.
2. **수신 인터럽트 처리 (RXIM/RTIM)**

   * 수신 링버퍼 잠금 후 DR에서 데이터 읽기.
   * 링버퍼에 적재 후 잠금 해제.
   * 관련 ICR 비트 클리어.
   * 수신 대기중 프로세스 깨움.
3. **송신 인터럽트 처리 (TXIM)**

   * `uart_tx_kick()` 호출.
   * TXIC 비트 클리어.
4. **처리 결과에 따라 IRQ\_HANDLED 또는 IRQ\_NONE 반환**.


## 7. 모듈 언로드 과정

1. **IMSC 비활성화**.
2. **ICR 클리어**.
3. **인터럽트 해제**

   * `free_irq()` 호출.
4. **레지스터 매핑 해제**

   * `iounmap()` 호출.
5. **캐릭터 디바이스 해제**.
6. **언로드 완료 로그 출력**.

